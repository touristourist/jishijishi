## 链表逆序操作（不创建额外结构和空间

使用head和prev两个指针，prev初始化为null，head初始化为原链表的头节点。head是当前逆序结果新的头，prev是这个新头的next

[详细链接](https://www.jianshu.com/p/43ff77f0da95)







#### 100位十进制数转化为二进制数

https://www.iteblog.com/archives/141.html

就是对字符串的操作，类似可以得出100位二进制数转化为十进制数的算法





#### 找出N个数中的前M大的数：  

https://blog.csdn.net/wangbaochu/article/details/52949443

使用**堆排序**，priority_queue最小堆，先将M个数压入堆中（**维护一个大小为M的堆**），然后读取接下来的数，和pq队列中的头比较，如果大于头，则将头弹出，压入该数。

对于n个数的堆排序，复杂度是O(nlogn)，但是此题中不需要对N个数排序，所以复杂度为O(n+mlogm) .

如果M仍很大，则可以将M分成多份M‘ ，这样求出第 $ceil[\frac{M}{M'}]$ 个就能找出第M个。

另外一种思想是用快排的思想，每次对一个数快排找到最终位置后，看最终位置K(下标为K)和M比较，从而知道需要继续处理左边还是右边。（这种只能用于找出第M大的数，复杂度为O(2n)=O(n) .





### 如何改进一个栈使得其min操作（找到最小值）只用O(1)复杂度

https://blog.csdn.net/ChenMiao0924/article/details/75714715

https://blog.csdn.net/tp93125334/article/details/52075437

**方法1：**  **使用两个栈s1保存所有元素**，s2栈顶保存s1中最小的元素。

 开始时两个栈皆为空，此时第一次元素入栈时两个栈都要。

有元素入栈： 比较其与s2.top()的大小，若**<=s2.top()** （注意有等于，因为要保证最小元素个数一致）就要将该元素入s1和s2 两栈，否则只用s1.

有元素出栈：比较该元素是否等于s2栈顶元素，若等于，则s2栈顶元素出栈，否则只用s1出栈。

**方法2：**（只用一个栈，栈顶元素就是当前最小元素）

入栈操作：

当栈为空时，第一次push放入两个元素。

当栈不为空时，**先将待入栈元素入栈**，然后比较该元素和之前栈顶元素的大小，**将更小的元素再入栈**，

出栈操作：

将栈顶两个元素都出栈，其中第二个出栈的元素就i是当前栈顶的元素。

找最小元素： 栈顶元素就是最小元素。